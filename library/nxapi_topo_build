#!/usr/bin/env python2.7

# Copyright (c) 2014 Matt Oswalt
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

DOCUMENTATION = '''
---
module: nxapi_topo_build
author: Matt Oswalt
version_added: 1.0
short_description: Build a table of Nexus 9000 connectivity.
description:
    - Connects to each "spine" switch, and uses CDP to generate a table of all 
      connected leaves.
requirements:
    - Mierdin's fork of nexus9000 https://github.com/Mierdin/nexus9000
options:
    host:
        description:
            - should be {{ inventory_hostname }}
        required: true  
    user:
        description:
            - login user-name 
        required: true
        default: "admin"
    passwd:
        description:
            - login password
        required: true 
        default: assumes ssh-key              
    logfile:
        description:
            - location for log file
        required: false 
        default: None        
'''

EXAMPLES = '''
# connect to group of spines and generate topology

- nxapi_topo_build:
    host={{ inventory_hostname }}
    user="admin"
    passwd="cisco"
    logfile="insieme.log"
  register: ins_topo

'''

from nxos.nxapi.utils.nxapi_utils import NXAPI
import logging
import json

def pcCheck(thisNXAPI, local_if):
    '''
    Checks if an interface is part of a port channel.
    If it is, this function returns the name of that port channel.
    If not, then the original local_if argument is returned.
    '''
    
    thisNXAPI.set_cmd('show interface ' + local_if)
    returnList = thisNXAPI.send_req()
    returnDict = json.loads(returnList[1])

    pcName = ""

    try:
        pcName = returnDict['ins_api']['outputs']['output']['body'] \
                ['TABLE_interface']['ROW_interface']['eth_bundle']
        #if key is present in dict, then port is a PC member
    except KeyError:
        logging.info (local_if + " is not a member of a port channel.")
        return local_if
    else:
        return pcName

def getCDPNeighbors(thisNXAPI):
    #thisSwitchDict = dict()
    
    thisNXAPI.set_cmd('show license host-id') #Using host-id as unique key
    returnList = thisNXAPI.send_req()
    returnDict = json.loads(returnList[1])
    #hostid = returnDict['ins_api']['outputs']['output']['body']['host_id']
    #thisSwitchDict['hostid'] = returnDict['ins_api']['outputs']['output'] \
     #       ['body']['host_id']


    thisNXAPI.set_cmd('show cdp neigh det')
    returnList = thisNXAPI.send_req()
    #thisSwitchDict['neighborinfo'] = json.loads(returnList[1])['ins_api'] \
    #        ['outputs']['output']['body']['TABLE_cdp_neighbor_detail_info'] \
    #        ['ROW_cdp_neighbor_detail_info']

    #TODO: Should really only get IP address and local interface here. \
        # need to create another method that logs into that switch and
        # flushes out this info in a table to be returned to this module.

    #"N9K-C9396PX"
    #"N9K-C9508"

    # Previously, I just returned the list located at: ['ins_api']['outputs'] \
    # ['output']['body']['TABLE_cdp_neighbor_detail_info'] - instead, I am \
    # carefully returning select information because the complexity involved \
    # in writing a playbook with this much info was too much. (nested lists \
    # and dictionaries). Instead, I'm returning my own dictionary from scratch

    # My "from scratch" dict, with only the info I need for this purpose.

    #getting rid of hostid for now, may want to re-enable
    #prunedInfo = dict(hostid=hostid)
    prunedInfo = dict()
    

    for row in json.loads(returnList[1])['ins_api']['outputs']['output'] \
            ['body']['TABLE_cdp_neighbor_detail_info'] \
            ['ROW_cdp_neighbor_detail_info']:
        
        if row['device_id'] in prunedInfo:
            continue #We already have this neighbor, no need to add it
        elif row['platform_id'][:3] != 'N9K':
            continue #We only want Nexus 9000s
            #TODO: may want to prune this down even more to only include leaves

        logging.info("Adding host to inventory: {}".format(row['device_id']))

        #prunedInfo['neighborinfo'] = dict()

        #getting remote interface details
        remoteNXAPI = NXAPI()
        remoteNXAPI.set_target_url('http://' + row['v4mgmtaddr'] + '/ins')
        
        #TODO: Need to re-design this. What if this switch's creds are \
                # not the same as the current node this module is running on?
        remoteNXAPI.set_username('admin')
        remoteNXAPI.set_password('Cisco.com')
        remoteNXAPI.set_out_format('json')
        remoteNXAPI.set_msg_type('cli_show')
        
        newItemDetails = dict()
        newItemDetails['local_if'] = pcCheck(thisNXAPI, row['intf_id'])
        newItemDetails['remote_if'] = pcCheck(remoteNXAPI, row['port_id'])
        newItemDetails['mgmt_ipv4'] = row['v4mgmtaddr']
        prunedInfo[row['device_id']] = newItemDetails

    return prunedInfo
    #return thisSwitchDict

def main():
    module = AnsibleModule(
        argument_spec=dict( \
            host=dict(required=True), \
            user=dict(required=False, default='admin'), \
            passwd=dict(required=False, default=None), \
            logfile=dict(required=False, default=None)), \
        supports_check_mode=False)

    m_args = module.params
    m_results = dict(changed=False)

    #Configure logging
    logfile = module.params.get('logfile')
    if logfile is not None:
        logging.basicConfig(filename=logfile, level=logging.INFO, \
          format='%(asctime)s:%(name)s:%(message)s')
        logging.getLogger().name = 'CONFIG:'+m_args['host']

    logging.info("Connecting to host: {}".format(m_args['host']))

    thisNXAPI = NXAPI()
    thisNXAPI.set_target_url('http://' + m_args['host'] + '/ins')
    thisNXAPI.set_username(m_args['user'])
    thisNXAPI.set_password(m_args['passwd'])
    thisNXAPI.set_out_format('json')
    thisNXAPI.set_msg_type('cli_show')

    m_results['topo'] = getCDPNeighbors(thisNXAPI)
    
    m_results['args'] = m_args        # for debug
    module.exit_json(**m_results)

from ansible.module_utils.basic import *
main()


