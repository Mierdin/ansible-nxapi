#!/usr/bin/env python2.7

# Copyright (c) 2014 Matt Oswalt
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

from nxos.nxapi.utils.nxapi_utils import NXAPI
import logging
import json

def ospfVerify(thisNXAPI, localPort, remotePort, neighborIPv4):
    """NeighborInfo is the dictionary for all leaves. 
        thisNXAPI is existing connnection to spine switch.

        Connects to both switches in a pair and validates OSPF operation
    """
    
    ospfReport = dict()

    logging.info("Hello -------- " + neighborIPv4)

    #neighborInfo['localPort']
    #neighborInfo['remotePort']
    #neighborInfo['neighborIPv4']

    #need to see if there is a neighbor on the other side
    #TODO: This is obviously catered for p2p links - need to \
            # be able to handle multiple neighbors
    thisNXAPI.set_cmd('show ip ospf nei int ' + localPort)
    returnList = thisNXAPI.send_req()
    returnDict = json.loads(returnList[1])

    try:
        neighborDict = returnDict['ins_api']['outputs']['output']['body'] \
                ['TABLE_ctx']['ROW_ctx']['TABLE_nbr']['ROW_nbr']
        ospfReport['state'] = neighborDict['state']
        ospfReport['uptime'] = neighborDict['uptime']

    except KeyError: #This is thrown if there is no neighbor
        ospfReport['nei_status'] = 'DOWN'
        ospfReport['nei_uptime'] = 'none'


    #time to gather more info
    thisNXAPI.set_cmd('show ip ospf int ' + localPort)
    returnList = thisNXAPI.send_req()
    returnDict = json.loads(returnList[1])
    for proc in returnDict['ins_api']['outputs']['output']['body'] \
            ['TABLE_ctx']['ROW_ctx']:
                #TODO: Note that ROW_ctx is a array. Shows up in other places 2
        
        # TODO: This is obviously bad, as it's statically setting the
        # OSPF process name. Need to re-do to handle multiple processes.   
        # best approach may be to specify the process name in the NXOS cmd
        if proc['ptag'] == 'CLOS':
            iface = proc['TABLE_intf']['ROW_intf']

            #Here I'm just capturing all I can about this interface to be
            #compared with the other switch's interface.
            ospfReport['ifname'] = iface['ifname']  
            ospfReport['admin_status'] = iface['admin_status']  
            ospfReport['proto_status'] = iface['proto_status']
            ospfReport['addr'] = iface['addr']
            ospfReport['masklen'] = iface['masklen']
            ospfReport['hello_interval'] = iface['hello_interval']
            ospfReport['dead_interval'] = iface['dead_interval']
            #There is also a "wait_interval" parameter - check this out
            ospfReport['auth_type'] = iface['auth_type']
            ospfReport['area'] = iface['area']
            #ospfReport[''] = iface['']
            #ospfReport[''] = iface['']
    
    #need to gather area information now
    thisNXAPI.set_cmd('show ip ospf CLOS') 
    #TODO: static process again, either make dynamic here, or loop through all
    returnList = thisNXAPI.send_req()
    returnDict = json.loads(returnList[1])
    
    #TODO: That stupid ROW issue (list or not list, etc)
    #for area in returnDict['ins_api']['outputs']['output']['body'] \
           # ['TABLE_ctx']['ROW_ctx']['TABLE_area']['ROW_area'].iteritems():
    area = returnDict['ins_api']['outputs']['output']['body']['TABLE_ctx'] \
            ['ROW_ctx']['TABLE_area']['ROW_area']
  
    #if area['aname'] == ospfReport['area']: #want the area our port is in
    ospfReport['area_stub'] = area['stub']
    ospfReport['area_nssa'] = area['nssa']
    #ospfReport['area_auth'] = area['auth_type'] # area auth?
        #break
 

    return ospfReport


def main():
    module = AnsibleModule(
        argument_spec=dict( \
            host=dict(required=True), \
            user=dict(required=False, default='admin'), \
            passwd=dict(required=False, default=None), \
            #operation=dict(required=True, default=None), \
            localPort=dict(required=True, default=None), \
            remotePort=dict(required=True, default=None), \
            neighborIPv4=dict(required=True, default=None), \
            logfile=dict(required=False, default=None)), \
        supports_check_mode=False)

    m_args = module.params
    m_results = dict(changed=False)

    #Configure logging
    logfile = module.params.get('logfile')
    if logfile is not None:
        logging.basicConfig(filename=logfile, level=logging.INFO,
                format='--- NXAPI_OSPF --- ' + 
                ' %(asctime)s:%(name)s:%(message)s')
				
        logging.getLogger().name = 'CONFIG:'+m_args['host']

    logging.info("Connecting to host: {}".format(m_args['host']))

    thisNXAPI = NXAPI()
    thisNXAPI.set_target_url('http://' + m_args['host'] + '/ins')
    thisNXAPI.set_username(m_args['user'])
    thisNXAPI.set_password(m_args['passwd'])
    thisNXAPI.set_out_format('json')
    thisNXAPI.set_msg_type('cli_show')

    m_results['ospfReport'] = ospfVerify(thisNXAPI, m_args['localPort'],
            m_args['remotePort'], m_args['neighborIPv4'])
    
    m_results['args'] = m_args        # for debug
    module.exit_json(**m_results)

from ansible.module_utils.basic import *
main()


